<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="专注于分布式高性能技术架构、IoT云平台、机器/深度学习">
<meta property="og:type" content="website">
<meta property="og:title" content="Technical Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Technical Blog">
<meta property="og:description" content="专注于分布式高性能技术架构、IoT云平台、机器/深度学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Technical Blog">
<meta name="twitter:description" content="专注于分布式高性能技术架构、IoT云平台、机器/深度学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> Technical Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Technical Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Welcome to my world!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/README/" itemprop="url">
                  分布式系统架构设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T20:46:25+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/" itemprop="url" rel="index">
                    <span itemprop="name">分布式&云计算</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/分布式技术架构/" itemprop="url" rel="index">
                    <span itemprop="name">分布式技术架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/README/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="README/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分布式配置管理"><a href="#分布式配置管理" class="headerlink" title="分布式配置管理"></a>分布式配置管理</h2><ul>
<li><a href="/consul">Consul</a> | etcd</li>
<li><a href="/archaius">Archaius动态管理</a></li>
<li><a href="/kubernetes-configmap/">Kubernetes ConfigMap</a></li>
<li><a href="/kubernetes-secrets/">Kubernetes Secrets</a></li>
</ul>
<p>配置的集中管理：采用consul的KV，将所有微服务的application.properties中的配置内容存入consul。</p>
<p>配置的动态管理：采用archaius，将consul上的配置信息读到spring的PropertySource和archaius的PollResult中，当修改了配置信息后，经常改变的值通过DynamicFactory来获取，不经常改变的值可以通过其他方式获取. 大部分情况下，修改了consul上的配置信息后，相应的项目不需要重启，也会读到最新的值。</p>
<h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><ul>
<li><a href="/consul/">Consul</a></li>
<li>Eureka | Zookeeper | etcd <a href="/servicediscovery">对比</a></li>
<li><a href="/kubernetes/#service">Kubernetes Service</a></li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ul>
<li><a href="/distributed-lock/">分布式锁</a></li>
</ul>
<h2 id="负载平衡"><a href="#负载平衡" class="headerlink" title="负载平衡"></a>负载平衡</h2><ul>
<li>Netflix Ribbon（Spring Cloud）</li>
<li><p><a href="/kubernetes/#service">Kubernetes Service</a></p>
<p><a href="/consul/">Client Side Load Balancing</a></p>
</li>
</ul>
<h2 id="API网关与智能路由"><a href="#API网关与智能路由" class="headerlink" title="API网关与智能路由"></a>API网关与智能路由</h2><ul>
<li>Netflix Zuul（SpringCloud）</li>
<li><a href="/kubernetes/#service">Kubernetes Service</a></li>
<li><p><a href="/kubernetes-ingress/">Kubernetes Ingress</a></p>
<p><a href="/gateway/">Gateway</a></p>
</li>
</ul>
<h2 id="分布式服务弹性与容错"><a href="#分布式服务弹性与容错" class="headerlink" title="分布式服务弹性与容错"></a>分布式服务弹性与容错</h2><ul>
<li>弹性服务</li>
<li>服务降级</li>
<li>线程池/信号隔离</li>
<li><p>快速解决依赖隔离</p>
<p><a href="/Hystrix/">Hystrix架构设计</a></p>
</li>
</ul>
<h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><ul>
<li>ELK Stack（LogStash -&gt; ES -&gt; Kibana）</li>
</ul>
<h2 id="分布式跟踪"><a href="#分布式跟踪" class="headerlink" title="分布式跟踪"></a>分布式跟踪</h2><ul>
<li>Zipkin</li>
<li><p>SpringCloud Sleuth</p>
<p><a href="/zipkin/">Zipkin</a> is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in microservice architectures. It manages both the collection and lookup of this data. Zipkin’s design is based on the Google Dapper paper.</p>
<p>Applications are instrumented to report timing data to Zipkin. The Zipkin UI also presents a Dependency diagram showing how many traced requests went through each application. If you are troubleshooting latency problems or errors, you can filter or sort all traces based on the application, length of trace, annotation, or timestamp. Once you select a trace, you can see the percentage of the total trace time each span takes which allows you to identify the problem application.</p>
</li>
</ul>
<h2 id="监控与度量"><a href="#监控与度量" class="headerlink" title="监控与度量"></a>监控与度量</h2><ul>
<li><p>Application/Infrastructure monitoring using StatsD + Graphite + Grafana</p>
<p><a href="/sgg/">StatsD + Graphite + Grafana</a></p>
</li>
</ul>
<h2 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h2><ul>
<li>SpringCloud Security</li>
</ul>
<h2 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h2><ul>
<li><a href="/kubernetes/#Autoscaling">Kubernetes Autoscaling</a></li>
</ul>
<h2 id="打包部署和调度部署"><a href="#打包部署和调度部署" class="headerlink" title="打包部署和调度部署"></a>打包部署和调度部署</h2><ul>
<li>Spring Boot；</li>
<li><a href="/kubernetes/#Deployment">Docker／Rkt、Kubernetes Scheduler&amp;Deployment</a></li>
</ul>
<h2 id="任务工作管理"><a href="#任务工作管理" class="headerlink" title="任务工作管理"></a>任务工作管理</h2><ul>
<li>Spring Batch</li>
<li><a href="/kubernetes/#Job">Kubernetes Jobs</a></li>
</ul>
<h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><h3 id="持久化-分布式文件系统"><a href="#持久化-分布式文件系统" class="headerlink" title="持久化 - 分布式文件系统"></a>持久化 - 分布式文件系统</h3><ul>
<li><a href="/hdfs/">HDFS分布式文件系统</a></li>
</ul>
<h3 id="持久化-分布式数据库"><a href="#持久化-分布式数据库" class="headerlink" title="持久化 - 分布式数据库"></a>持久化 - 分布式数据库</h3><ul>
<li>[传统关系型数据库集群,如MySQL Cluster]</li>
<li><a href="/mongo/">Mongo</a></li>
<li><a href="/hbase/">Cassandra,HBase</a></li>
</ul>
<h3 id="非持久化-分布式缓存-消息系统"><a href="#非持久化-分布式缓存-消息系统" class="headerlink" title="非持久化 - 分布式缓存/消息系统"></a>非持久化 - 分布式缓存/消息系统</h3><ul>
<li><a href="/kafka/">Kafka</a></li>
<li>[Redis]</li>
</ul>
<h2 id="分布式计算框架"><a href="#分布式计算框架" class="headerlink" title="分布式计算框架"></a>分布式计算框架</h2><ul>
<li><a href="/yarn/">YARN分布式计算框架</a></li>
<li><a href="/yarn-appdev/">YARN应用开发的几种方式</a></li>
<li><a href="/running-spark-on-yarn/">Running Spark on YARN</a></li>
<li><a href="/spark/">Spark Big Data Analytics</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/sgg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/sgg/" itemprop="url">
                  StatsD - Graphite - Grafana
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T20:46:25+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/sgg/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="sgg/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#1. StatsD - metrics data collecting</p>
<ul>
<li>In your application code, use the StatsD client (e.g. Java client library) to collect and send the statistics and aggregation data to StatsD server;</li>
<li>Not need to pre-define the metrics in anywhere, just place them into your application code;</li>
<li>By default, stats data are aggregated and sent to Graphite server by every 10 seconds, so think this near-realtime;</li>
</ul>
<p>#2. Graphite - metrics data graphing and storage</p>
<ul>
<li>Store numeric time-series data: The metric data would be stored into Graphite server (include a Whisper database);</li>
<li>Render the graph for metrics data per the metrics demand;</li>
<li>The pre-built UI dashboard is not powerful shown as below, but can easily use it to view the metrics data;</li>
<li>For production environment, Graphite server should be running as cluster instead of stand-alone server;</li>
</ul>
<p>#3. Grafana - powerful dashboard for visualizing the metrics data</p>
<ul>
<li>easy to integrate with Graphite to visualize the metrics data;</li>
<li>input the Graphite HTTP URL to link to Graphite as data source;</li>
<li>powerful pre-built reporting charts and dashboard;</li>
</ul>
<p>#4.  Sample Code:</p>
<ul>
<li>easy to feed the data to StatsD -&gt; Graphite -&gt; Grafana<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private static final StatsDClient statsd = new NonBlockingStatsDClient(&quot;app.api-analytics.sample&quot;, &quot;127.0.0.1&quot;,</div><div class="line">     8125);</div><div class="line">statsd.count(&quot;get.request&quot;, (long)(Math.random()* 10)); // Request count of this API</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/spark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/spark/" itemprop="url">
                  Spark
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T20:46:25+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/spark/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="spark/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/kubernetes-secrets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/kubernetes-secrets/" itemprop="url">
                  Kubernetes Secrets
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T20:46:25+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/" itemprop="url" rel="index">
                    <span itemprop="name">分布式&云计算</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/kubernetes-secrets/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="kubernetes-secrets/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Secrets描述"><a href="#Secrets描述" class="headerlink" title="Secrets描述"></a>Secrets描述</h2><p>在Kubernetes中，Secret对象类型主要目的是保存一些私密数据，比如密码, tokens, ssh keys等信息。将这些信息放在Secret对象中比直接放在pod或docker image中更安全，也更方便使用。</p>
<p>创建Secrets对象的方式有两种，一种是用户手动创建，另一种是集群自动创建。<br>一个已经创建好的Secrets对象有两种方式被pod对象使用，其一，在container中的volume对象里以file的形式被使用，其二，在pull images时被kubelet使用。</p>
<p>为了使用Secret对象，pod必须引用这个Secret，同样可以手动或者自动来执行引用操作。</p>
<h2 id="Built-in-Secrets"><a href="#Built-in-Secrets" class="headerlink" title="Built-in Secrets"></a>Built-in Secrets</h2><p>Kubernetes会自动创建包含证书信息的Secret，并且使用它来访问api, Kubernetes也将自动修改pod来使用这个Secret。</p>
<p>自动创建的Secret以及所使用的api证书,可以根据需要disable或者override。如果仅仅需要安全访问apiserver，那么上述的流程是推荐的方式。</p>
<h2 id="自定义Secrets"><a href="#自定义Secrets" class="headerlink" title="自定义Secrets"></a>自定义Secrets</h2><h3 id="通过kubectl自定义Secrets"><a href="#通过kubectl自定义Secrets" class="headerlink" title="通过kubectl自定义Secrets"></a>通过kubectl自定义Secrets</h3><p>数据中的字段为map类型。其中keys必须符合dns_subdomain规则，values可以为任意类型，使用base64编码。上述例子中，username和password的数据值在base64编码前的值为value-1 和 value-2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ echo -n &quot;admin&quot; &gt; ./username.txt</div><div class="line">xis-macbook-pro:~ xiningwang$  echo -n &quot;1f2d1e2e67df&quot; &gt; ./password.txt</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt</div><div class="line">secret &quot;db-user-pass&quot; created</div></pre></td></tr></table></figure></p>
<p>查看创建的Secrets:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get secrets</div><div class="line">NAME                  TYPE                                  DATA      AGE</div><div class="line">db-user-pass          Opaque                                2         6m</div><div class="line">default-token-t5bk8   kubernetes.io/service-account-token   3         4d</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl describe secrets/db-user-pass</div><div class="line">Name:  		db-user-pass</div><div class="line">Namespace:     	default</div><div class="line">Labels:		&lt;none&gt;</div><div class="line">Annotations:   	&lt;none&gt;</div><div class="line"></div><div class="line">Type:  	Opaque</div><div class="line"></div><div class="line">Data</div><div class="line">====</div><div class="line">password.txt:  	12 bytes</div><div class="line">username.txt:  	5 bytes</div></pre></td></tr></table></figure></p>
<h3 id="手工创建Secrets"><a href="#手工创建Secrets" class="headerlink" title="手工创建Secrets"></a>手工创建Secrets</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ echo -n &quot;admin&quot; | base64</div><div class="line">YWRtaW4=</div><div class="line">xis-macbook-pro:~ xiningwang$ echo -n &quot;1f2d1e2e67df&quot; | base64</div><div class="line">MWYyZDFlMmU2N2Rm</div><div class="line">xis-macbook-pro:~ xiningwang$ vi mysecrect.yaml</div><div class="line">apiVersion: v1</div><div class="line">kind: Secret</div><div class="line">metadata:</div><div class="line">  name: mysecret</div><div class="line">type: Opaque</div><div class="line">data:</div><div class="line">  username: YWRtaW4=</div><div class="line">  password: MWYyZDFlMmU2N2Rm</div></pre></td></tr></table></figure>
<p>使用yaml文件创建Secrets:</p>
<blockquote>
<p>xis-macbook-pro:~ xiningwang$ kubectl create -f ./mysecrect.yaml<br>secret “mysecret” created</p>
</blockquote>
<h2 id="查看Secrets"><a href="#查看Secrets" class="headerlink" title="查看Secrets"></a>查看Secrets</h2><p>使用如下命令获取创建的Secrets内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get secret db-user-pass -o yaml</div><div class="line">apiVersion: v1</div><div class="line">data:</div><div class="line">  password.txt: MWYyZDFlMmU2N2Rm</div><div class="line">  username.txt: YWRtaW4=</div><div class="line">kind: Secret</div><div class="line">metadata:</div><div class="line">  creationTimestamp: 2017-05-09T07:54:29Z</div><div class="line">  name: db-user-pass</div><div class="line">  namespace: default</div><div class="line">  resourceVersion: &quot;84609&quot;</div><div class="line">  selfLink: /api/v1/namespaces/default/secrets/db-user-pass</div><div class="line">  uid: bb23a365-348c-11e7-ab36-080027fd8883</div><div class="line">type: Opaque</div></pre></td></tr></table></figure></p>
<p>base64解密:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;MWYyZDFlMmU2N2Rm&quot; | base64 --decode</div><div class="line">1f2d1e2e67df</div></pre></td></tr></table></figure></p>
<h2 id="使用Secrets"><a href="#使用Secrets" class="headerlink" title="使用Secrets"></a>使用Secrets</h2><h3 id="手动为pod绑定secret"><a href="#手动为pod绑定secret" class="headerlink" title="手动为pod绑定secret"></a>手动为pod绑定secret</h3><p>必须有spec.volumes才能使用secret。 如果一个pod中有多个container，每个container需要他们单独对应的volumeMounts ，但是一个secret只能对应一个spec.volumes。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> &quot;apiVersion&quot;: &quot;v1&quot;,</div><div class="line"> &quot;kind&quot;: &quot;Pod&quot;,</div><div class="line">  &quot;metadata&quot;: &#123;</div><div class="line">    &quot;name&quot;: &quot;mypod&quot;,</div><div class="line">    &quot;namespace&quot;: &quot;myns&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;spec&quot;: &#123;</div><div class="line">    &quot;containers&quot;: [&#123;</div><div class="line">      &quot;name&quot;: &quot;mypod&quot;,</div><div class="line">      &quot;image&quot;: &quot;redis&quot;,</div><div class="line">      &quot;volumeMounts&quot;: [&#123;</div><div class="line">        &quot;name&quot;: &quot;foo&quot;,</div><div class="line">        &quot;mountPath&quot;: &quot;/etc/foo&quot;,</div><div class="line">        &quot;readOnly&quot;: true</div><div class="line">      &#125;]</div><div class="line">    &#125;],</div><div class="line">    &quot;volumes&quot;: [&#123;</div><div class="line">      &quot;name&quot;: &quot;foo&quot;,</div><div class="line">      &quot;secret&quot;: &#123;</div><div class="line">        &quot;secretName&quot;: &quot;mysecret&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看Secrets的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ls /etc/foo/</div><div class="line">username</div><div class="line">password</div><div class="line">$ cat /etc/foo/username</div><div class="line">admin</div><div class="line">$ cat /etc/foo/password</div><div class="line">1f2d1e2e67df</div></pre></td></tr></table></figure></p>
<h3 id="使用Secrets作为环境变量"><a href="#使用Secrets作为环境变量" class="headerlink" title="使用Secrets作为环境变量"></a>使用Secrets作为环境变量</h3><blockquote>
<p> 定义对Secrets的引用: env[x].valueFrom.secretKeyRef.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: secret-env-pod</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">    - name: mycontainer</div><div class="line">      image: redis</div><div class="line">      env:</div><div class="line">        - name: SECRET_USERNAME</div><div class="line">          valueFrom:</div><div class="line">            secretKeyRef:</div><div class="line">              name: mysecret</div><div class="line">              key: username</div><div class="line">        - name: SECRET_PASSWORD</div><div class="line">          valueFrom:</div><div class="line">            secretKeyRef:</div><div class="line">              name: mysecret</div><div class="line">              key: password</div><div class="line">  restartPolicy: Never</div></pre></td></tr></table></figure>
<p>查看Secrets的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo $SECRET_USERNAME</div><div class="line">admin</div><div class="line">$ echo $SECRET_PASSWORD</div><div class="line">1f2d1e2e67df</div></pre></td></tr></table></figure></p>
<h2 id="Secret与Pod的生命周期"><a href="#Secret与Pod的生命周期" class="headerlink" title="Secret与Pod的生命周期"></a>Secret与Pod的生命周期</h2><p>当通过api创建一个pod后，不会去检查所引用的secret是否存在。一旦这个pod被使用，kubelet将会尝试去获取引用的secret的值。如果这个secret不存在，或者kubelet暂时链接不上apiserver，kubelet将会定期重试，并发送一个event来解释pod没有启动的原因。如果获取到了对应的secret，kubelet将会创建对应的volume并绑定到container。</p>
<p>一旦kubelet创建了一个pod，则container使用的相关secret volume不会在改变，即使对应的secret对象被修改。如果为了改变使用的secret，则必须删除旧的pod，并重新创建一个新的pod。</p>
<p>##限制<br>在使用之前，Secret volume 资源被验证，以确保指定的对象引用真是指向一个secret对象。因此，在pod使用它之前必须保证需要的secret被成功创建。Secret api对象从属于namespace，一个Secret对象只能被同namespace的pod所使用。</p>
<p>单个secret限制在1Mb之内，防止过大的secret耗尽apiserver &amp; kubelet的内存。然而，创建许多类似的secret同样也会无用的消耗掉apiserver&amp;kubelet的内存。</p>
<p>kubelet目前只支持pod使用来自于apiserver的secret。pods包括了被 kubectl创建的pod 或者 被replication controller间接创建的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/kubernetes-ingress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/kubernetes-ingress/" itemprop="url">
                  Kubernetes Ingress
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T20:46:25+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/" itemprop="url" rel="index">
                    <span itemprop="name">分布式&云计算</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/kubernetes-ingress/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="kubernetes-ingress/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul>
<li>节点：Kubernetes集群中的一台物理机或者虚拟机。</li>
<li>集群：位于Internet防火墙后的节点，这是kubernetes管理的主要计算资源。</li>
<li>边界路由器：为集群强制执行防火墙策略的路由器。 这可能是由云提供商或物理硬件管理的网关。</li>
<li>集群网络：一组逻辑或物理链接，可根据Kubernetes 网络模型 实现群集内的通信。 集群网络的实现包括Overlay模型的 flannel 和基于SDN的 OVS 。</li>
<li>服务：使用标签选择器标识一组pod成为的Kubernetes 服务 。 除非另有说明，否则服务假定在集群网络内仅可通过虚拟IP访问。</li>
</ul>
<p>毋庸置疑,容器是未来的最为重要的配置编排格式之一, 打包应用程序也将会变得更加容易。虽然像Docker这样的工具提供真实的容器，但是也需要其他工具来处理如replication，failover以及API来自动化部署到多个机器。</p>
<p>Service在部署之前存在一个IP地址，但是这个地址只存在于Kubernetes集群之内。这也就意味着service对于网络来说根本不可用！当运行在谷歌GCE上的时候（像我们一样），Kubernetes能够自动配置一个负载均衡器来访问应用程序。如果你不是在谷歌GCE上面的话，你就需要做些额外的工作来使负载均衡运行起来。</p>
<p>将service直接暴露到一个主机端口也可以，这就是经常使用的方式，但这会令很多Kubernetes的优势无法充分发挥。如果依赖主机上的端口，那么当部署多个应用程序的时候，就会陷入端口冲突,这也使得调度集群或者替代主机变得更加困难。</p>
<h2 id="什么是Ingress"><a href="#什么是Ingress" class="headerlink" title="什么是Ingress"></a>什么是Ingress</h2><p>通常情况下，service和pod仅可在集群内部网络中通过IP地址访问。所有到达边界路由器的流量或被丢弃或被转发到其他地方。从概念上讲，可能像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  internet</div><div class="line">      |</div><div class="line">------------</div><div class="line">[ Services ]</div></pre></td></tr></table></figure></p>
<p>Ingress是授权入站连接到达集群服务的规则集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> internet</div><div class="line">     |</div><div class="line">[ Ingress ]</div><div class="line">--|-----|--</div><div class="line">[ Services ]</div></pre></td></tr></table></figure>
<p>可以给Ingress配置提供外部可访问的URL、负载均衡、SSL、基于名称的虚拟主机等。用户通过POST Ingress资源到API server的方式来请求ingress。 Ingress controller 负责实现Ingress，通常使用负载平衡器，它还可以配置边界路由和其他前端，这有助于以HA方式处理流量。</p>
<h2 id="自定义Secrets"><a href="#自定义Secrets" class="headerlink" title="自定义Secrets"></a>自定义Secrets</h2><p>最简化的Ingress配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Ingress</div><div class="line">metadata:</div><div class="line">  name: test-ingress</div><div class="line">spec:</div><div class="line">  rules:</div><div class="line">  - http:</div><div class="line">      paths:</div><div class="line">      - path: /testpath</div><div class="line">        backend:</div><div class="line">          serviceName: test</div><div class="line">          servicePort: 80</div></pre></td></tr></table></figure>
<p>1-4行：跟Kubernetes的其他配置一样，ingress的配置也需要 apiVersion ， kind 和 metadata 字段。配置文件的详细说明请查看 部署应用 , 配置容器 和 使用resources .</p>
<p>5-7行: Ingress spec 中包含配置一个loadbalancer或proxy server的所有信息。最重要的是，它包含了一个匹配所有入站请求的规则列表。目前ingress只支持http规则。</p>
<p>8-9行：每条http规则包含以下信息：一个 host 配置项（比如for.bar.com，在这个例子中默认是*）， path 列表（比如：/testpath），每个path都关联一个 backend (比如test:80)。在loadbalancer将流量转发到backend之前，所有的入站请求都要先匹配host和path。</p>
<p>10-12行：正如 services doc 中描述的那样，backend是一个 service:port 的组合。Ingress的流量被转发到它所匹配的backend。</p>
<h2 id="Ingress类型"><a href="#Ingress类型" class="headerlink" title="Ingress类型"></a>Ingress类型</h2><h3 id="单Service-Ingress"><a href="#单Service-Ingress" class="headerlink" title="单Service Ingress"></a>单Service Ingress</h3><p>Kubernetes中已经存在一些概念可以暴露单个service（查看 替代方案 ），但是你仍然可以通过Ingress来实现，通过指定一个没有rule的默认backend的方式。</p>
<p>ingress.yaml定义文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Ingress</div><div class="line">metadata:</div><div class="line">  name: test-ingress</div><div class="line">spec:</div><div class="line">  backend:</div><div class="line">    serviceName: testsvc</div><div class="line">    servicePort: 80</div></pre></td></tr></table></figure></p>
<p>使用 kubectl create -f 命令创建，然后查看ingress：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ kubectl get ing</div><div class="line">NAME                RULE          BACKEND        ADDRESS</div><div class="line">test-ingress        -             testsvc:80     107.178.254.228</div></pre></td></tr></table></figure></p>
<h3 id="简单展开"><a href="#简单展开" class="headerlink" title="简单展开"></a>简单展开</h3><p>如前面描述的那样，kubernete pod中的IP只在集群网络内部可见，我们需要在边界设置一个东西，让它能够接收ingress的流量并将它们转发到正确的端点上。这个东西一般是高可用的loadbalancer。使用Ingress能够允许你将loadbalancer的个数降低到最少，例如，嫁入你想要创建这样的一个设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo.bar.com -&gt; 178.91.123.132 -&gt; / foo    s1:80</div><div class="line">                                 / bar    s2:80</div></pre></td></tr></table></figure></p>
<p>需要一个这样的ingress：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Ingress</div><div class="line">metadata:</div><div class="line">  name: test</div><div class="line">spec:</div><div class="line">  rules:</div><div class="line">  - host: foo.bar.com</div><div class="line">    http:</div><div class="line">      paths:</div><div class="line">      - path: /foo</div><div class="line">        backend:</div><div class="line">          serviceName: s1</div><div class="line">          servicePort: 80</div><div class="line">      - path: /bar</div><div class="line">        backend:</div><div class="line">          serviceName: s2</div><div class="line">          servicePort: 80</div></pre></td></tr></table></figure></p>
<p>使用 kubectl create -f 创建完ingress后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ kubectl get ing</div><div class="line">NAME      RULE          BACKEND   ADDRESS</div><div class="line">test      -</div><div class="line">          foo.bar.com</div><div class="line">          /foo          s1:80</div><div class="line">          /bar          s2:80</div></pre></td></tr></table></figure></p>
<h3 id="基于名称的虚拟主机"><a href="#基于名称的虚拟主机" class="headerlink" title="基于名称的虚拟主机"></a>基于名称的虚拟主机</h3><p>Name-based的虚拟主机在同一个IP地址下拥有多个主机名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo.bar.com --|                 |-&gt; foo.bar.com s1:80</div><div class="line">              | 178.91.123.132  |</div><div class="line">bar.foo.com --|                 |-&gt; bar.foo.com s2:80</div></pre></td></tr></table></figure></p>
<p>下面这个ingress说明基于 Host header 的后端loadbalancer的路由请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Ingress</div><div class="line">metadata:</div><div class="line">  name: test</div><div class="line">spec:</div><div class="line">  rules:</div><div class="line">  - host: foo.bar.com</div><div class="line">    http:</div><div class="line">      paths:</div><div class="line">      - backend:</div><div class="line">          serviceName: s1</div><div class="line">          servicePort: 80</div><div class="line">  - host: bar.foo.com</div><div class="line">    http:</div><div class="line">      paths:</div><div class="line">      - backend:</div><div class="line">          serviceName: s2</div><div class="line">          servicePort: 80</div></pre></td></tr></table></figure></p>
<h2 id="使用Nginx设置负载均衡"><a href="#使用Nginx设置负载均衡" class="headerlink" title="使用Nginx设置负载均衡"></a>使用Nginx设置负载均衡</h2><p>在任意情况下，当创建新的Kubernetes services的时候，需要一个机制来动态地重新部署负载均衡器.</p>
<p>通过使用confd来检测配置在etcd内的修改，并基于一个模版生成一个新的nginx配置文件.</p>
<p><img src="/images/ingress-nginx.png" alt="ingress-nginx"></p>
<h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>可以通过很多种方式暴露service而不必直接使用ingress：</p>
<ul>
<li>使用 Service.Type=LoadBalancer</li>
<li>使用 Service.Type=NodePort</li>
<li>使用 Port Proxy</li>
<li>部署一个 Service loadbalancer 这允许你在多个service之间共享单个IP，并通过Service Annotations实现更高级的负载平衡。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/kubernetes-configmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/kubernetes-configmap/" itemprop="url">
                  Kubernetes ConfigMap
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T20:46:25+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/" itemprop="url" rel="index">
                    <span itemprop="name">分布式&云计算</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/kubernetes-configmap/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="kubernetes-configmap/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>很多应用程序的配置需要通过配置文件，命令行参数和环境变量的组合配置来完成。这些配置应该从image内容中解耦，以此来保持容器化应用程序的便携性。ConfigMap API资源提供了将配置数据注入容器的方式，同时保持容器是不知道Kubernetes的。ConfigMap可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象。</p>
<blockquote>
<p>kubernetes通过ConfigMap来实现对容器中应用的配置管理。</p>
</blockquote>
<p>从数据角度来看，ConfigMap的类型只是键值组。应用可以从不同角度来配置，所以关于给用户如何存储和使用配置数据，我们需要给他们一些弹性。在一个pod里面使用ConfigMap大致有三种方式：</p>
<ul>
<li>环境变量</li>
<li>命令行参数</li>
<li>数据卷文件</li>
</ul>
<h2 id="创建ConfigMap"><a href="#创建ConfigMap" class="headerlink" title="创建ConfigMap"></a>创建ConfigMap</h2><p>创建ConfigMap的方式有两种，一种是通过yaml文件来创建，另一种是通过kubectl直接在命令行下创建。</p>
<h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><p>在yaml文件中，配置文件以key-value键值对的形式保存，当然也可以直接放一个完整的配置文件，在下面的示例中，cache_hst、cache_port、cache_prefix即是key-value键值对，而app.properties和my.cnf都是配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: ConfigMap</div><div class="line">metadata:</div><div class="line">  name: test-cfg</div><div class="line">  namespace: default</div><div class="line">data:</div><div class="line">  cache_host: memcached-gcxt</div><div class="line">  cache_port: &quot;11211&quot;</div><div class="line">  cache_prefix: gcxt</div><div class="line">  my.cnf: |</div><div class="line">    [mysqld]</div><div class="line">    log-bin = mysql-bin</div><div class="line">  app.properties: |</div><div class="line">    property.1 = value-1</div><div class="line"> property.2 = value-2</div><div class="line"> property.3 = value-3</div></pre></td></tr></table></figure></p>
<p>创建ConfigMap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl create -f test-cfg.yml</div></pre></td></tr></table></figure></p>
<h3 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h3><p>直接将一个目录下的所有配置文件创建为一个ConfigMap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl create configmap test-config --from-file=./configs</div></pre></td></tr></table></figure></p>
<p>直接将一个配置文件创建为一个ConfigMap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl create configmap test-config2 --from-file=./configs/db.conf --from-file=./configs/cache.conf</div></pre></td></tr></table></figure></p>
<p>在使用kubectl创建的时候，通过在命令行直接传递键值对创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl create configmap test-config3 --from-literal=db.host=10.5.10.116 --from-listeral=db.port=&apos;3306&apos;</div></pre></td></tr></table></figure></p>
<p>可以通过如下方式查看创建的ConfigMap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kubectl get configmaps</div><div class="line">kubectl get configmap test-config -o yaml</div><div class="line">kubectl describe configmap test-config</div></pre></td></tr></table></figure></p>
<h2 id="使用ConfigMap"><a href="#使用ConfigMap" class="headerlink" title="使用ConfigMap"></a>使用ConfigMap</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>通过环境变量的方式，直接传递pod.<br>ConfigMap文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: ConfigMap</div><div class="line">metadata:</div><div class="line">  name: special-config</div><div class="line">  namespace: default</div><div class="line">data:</div><div class="line">  special.how: very</div><div class="line">  special.type: charm</div></pre></td></tr></table></figure></p>
<p>第一个pod示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: dapi-test-pod</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">    - name: test-container</div><div class="line">      image: gcr.io/google_containers/busybox</div><div class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]</div><div class="line">      env:</div><div class="line">        - name: SPECIAL_LEVEL_KEY</div><div class="line">          valueFrom:</div><div class="line">            configMapKeyRef:</div><div class="line">              name: special-config</div><div class="line">              key: special.how</div><div class="line">        - name: SPECIAL_TYPE_KEY</div><div class="line">          valueFrom:</div><div class="line">            configMapKeyRef:</div><div class="line">              name: special-config</div><div class="line">              key: special.type</div><div class="line">  restartPolicy: Never</div></pre></td></tr></table></figure></p>
<p>第二个pod示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: dapi-test-pod</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">    - name: test-container</div><div class="line">      image: gcr.io/google_containers/busybox</div><div class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ]</div><div class="line">      env:</div><div class="line">        - name: CACHE_HOST</div><div class="line">          valueFrom:</div><div class="line">            configMapKeyRef:</div><div class="line">              name: test-cfg</div><div class="line">              key: cache_host</div><div class="line">              optional: true</div><div class="line">  restartPolicy: Never</div></pre></td></tr></table></figure></p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>在命令行下引用时，需要先设置为环境变量，之后 可以通过$(VAR_NAME)设置容器启动命令的启动参数.<br>ConfigMap文件示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: ConfigMap</div><div class="line">metadata:</div><div class="line">  name: special-config</div><div class="line">  namespace: default</div><div class="line">data:</div><div class="line">  special.how: very</div><div class="line">  special.type: charm</div></pre></td></tr></table></figure></p>
<p>Pod示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: dapi-test-pod</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">    - name: test-container</div><div class="line">      image: gcr.io/google_containers/busybox</div><div class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&quot; ]</div><div class="line">      env:</div><div class="line">        - name: SPECIAL_LEVEL_KEY</div><div class="line">          valueFrom:</div><div class="line">            configMapKeyRef:</div><div class="line">              name: special-config</div><div class="line">              key: special.how</div><div class="line">        - name: SPECIAL_TYPE_KEY</div><div class="line">          valueFrom:</div><div class="line">            configMapKeyRef:</div><div class="line">              name: special-config</div><div class="line">              key: special.type</div><div class="line">  restartPolicy: Never</div></pre></td></tr></table></figure></p>
<h3 id="数据卷文件"><a href="#数据卷文件" class="headerlink" title="数据卷文件"></a>数据卷文件</h3><p>使用volume将ConfigMap作为文件或目录直接挂载，其中每一个key-value键值对都会生成一个文件，key为文件名，value为内容.<br>ConfigMap示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: ConfigMap</div><div class="line">metadata:</div><div class="line">  name: special-config</div><div class="line">  namespace: default</div><div class="line">data:</div><div class="line">  special.how: very</div><div class="line">  special.type: charm</div></pre></td></tr></table></figure></p>
<p>第一个pod示例，简单的将上面创建的ConfigMap直接挂载至pod的/etc/config目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: dapi-test-pod</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">    - name: test-container</div><div class="line">      image: gcr.io/google_containers/busybox</div><div class="line">      command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat /etc/config/special.how&quot; ]</div><div class="line">      volumeMounts:</div><div class="line">      - name: config-volume</div><div class="line">        mountPath: /etc/config</div><div class="line">  volumes:</div><div class="line">    - name: config-volume</div><div class="line">      configMap:</div><div class="line">        name: special-config</div><div class="line">  restartPolicy: Never</div></pre></td></tr></table></figure></p>
<p>第二个pod示例，只将ConfigMap的special.how这个key挂载到/etc/config目录下的一个相对路径path/to/special-key，如果存在同名文件，直接覆盖。其他的key不挂载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: dapi-test-pod</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">    - name: test-container</div><div class="line">      image: gcr.io/google_containers/busybox</div><div class="line">      command: [ &quot;/bin/sh&quot;,&quot;-c&quot;,&quot;cat /etc/config/path/to/special-key&quot; ]</div><div class="line">      volumeMounts:</div><div class="line">      - name: config-volume</div><div class="line">        mountPath: /etc/config</div><div class="line">  volumes:</div><div class="line">    - name: config-volume</div><div class="line">      configMap:</div><div class="line">        name: special-config</div><div class="line">        items:</div><div class="line">        - key: special.how</div><div class="line">          path: path/to/special-key</div><div class="line">  restartPolicy: Never</div></pre></td></tr></table></figure></p>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ul>
<li>ConfigMap必须在Pod之前创建</li>
<li>只有与当前ConfigMap在同一个namespace内的pod才能使用这个ConfigMap，换句话说，ConfigMap不能跨命名空间调用。</li>
<li>很多生产环境中的应用程序配置较为复杂，可能需要多个config文件、命令行参数和环境变量的组合。并且，这些配置信息应该从应用程序镜像中解耦出来，以保证镜像的可移植性以及配置信息不被泄露。社区引入ConfigMap这个API资源来满足这一需求。</li>
<li>ConfigMap包含了一系列的键值对，用于存储被Pod或者系统组件（如controller）访问的信息。这与secret的设计理念有异曲同工之妙，它们的主要区别在于ConfigMap通常不用于存储敏感信息，而只存储简单的文本信息。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/redis/" itemprop="url">
                  Redis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-02T20:46:25+08:00">
                2017-03-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/redis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="redis/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>docker run –name myredis -v /Users/xiningwang/nosql/redis/redis-3.2.8/data:/data -p 6379:6379 -d redis redis-server –appendonly yes</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/kubernetes/" itemprop="url">
                  Kubernetes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-12T20:46:25+08:00">
                2017-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/" itemprop="url" rel="index">
                    <span itemprop="name">分布式&云计算</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式-云计算/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/kubernetes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="kubernetes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>Kubernetes将底层的计算资源连接在一起对外体现为一个计算集群，并将资源高度抽象化。部署应用时Kubernetes会以更高效的方式自动的将应用分发到集群内的机器上面，并调度运行。</p>
<p>Kubernetes集群包含两种类型的资源：</p>
<ul>
<li>Master节点：协调控制整个集群。Master负责管理整个集群，协调集群内的所有行为。比如调度应用，监控应用的状态等。</li>
<li>Nodes节点：运行应用的工作节点。Node节点负责运行应用，一般是一台物理机或者虚机。每个Node节点上面都有一个Kubelet，它是一个代理程序，用来管理该节点以及和Master节点通信。除此以外，Node节点上还会有一些管理容器的工具，比如Docker或者rkt等。生产环境中一个Kubernetes集群至少应该包含三个Nodes节点。</li>
</ul>
<p>当部署应用的时候，我们通知Master节点启动应用容器。然后Master会调度这些应用将它们运行在Node节点上面。Node节点和Master节点通过Master节点暴露的Kubernetes API通信。当然我们也可以直接通过这些API和集群交互。<br><img src="http://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg" alt="kubernetes Cluster"></p>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Master节点上面主要由四个模块组成：APIServer、scheduler、controller manager、etcd。</p>
<ul>
<li>APIServer<br>APIServer负责对外提供RESTful的Kubernetes API服务，它是系统管理指令的统一入口，任何对资源进行增删改查的操作都要交给APIServer处理后再提交给etcd。如架构图中所示，kubectl（Kubernetes提供的客户端工具，该工具内部就是对Kubernetes API的调用）是直接和APIServer交互的。</li>
<li>Scheduler<br>Scheduler的职责很明确，就是负责调度pod到合适的Node上。如果把scheduler看成一个黑匣子，那么它的输入是pod和由多个Node组成的列表，输出是Pod和一个Node的绑定，即将这个pod部署到这个Node上。Kubernetes目前提供了调度算法，但是同样也保留了接口，用户可以根据自己的需求定义自己的调度算法。</li>
<li>Controller manager<br>如果说APIServer做的是“前台”的工作的话，那controller manager就是负责“后台”的。每个资源一般都对应有一个控制器，而controller manager就是负责管理这些控制器的。比如我们通过APIServer创建一个pod，当这个pod创建成功后，APIServer的任务就算完成了。而后面保证Pod的状态始终和我们预期的一样的重任就由controller manager去保证了。</li>
<li>etcd<br>etcd是一个高可用的键值存储系统，Kubernetes使用它来存储各个资源的状态，从而实现了Restful的API。</li>
</ul>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>每个Node节点主要由三个模块组成：kubelet、kube-proxy、runtime。</p>
<ul>
<li>kubelet。Kubelet是Master在每个Node节点上面的agent，是Node节点上面最重要的模块，它负责维护和管理该Node上面的所有容器，但是如果容器不是通过Kubernetes创建的，它并不会管理。本质上，它负责使Pod得运行状态与期望的状态一致。</li>
<li>kube-proxy。该模块实现了Kubernetes中的服务发现和反向代理功能。反向代理方面：kube-proxy支持TCP和UDP连接转发，默认基于Round Robin算法将客户端流量转发到与service对应的一组后端pod。服务发现方面，kube-proxy使用etcd的watch机制，监控集群中service和endpoint对象数据的动态变化，并且维护一个service到endpoint的映射关系，从而保证了后端pod的IP变化不会对访问者造成影响。另外kube-proxy还支持session affinity。</li>
<li>runtime。runtime指的是容器运行环境，目前Kubernetes支持docker和rkt两种容器。</li>
</ul>
<h2 id="搭建MiniKube"><a href="#搭建MiniKube" class="headerlink" title="搭建MiniKube"></a>搭建MiniKube</h2><p>环境: MacOS, virtualbox, minikube v0.18.0, kubectl v1.6.0</p>
<p>Kubernetes提供了一个轻量级的Minikube应用，利用它我们可以很容器的创建一个只包含一个Node节点的Kubernetes Cluster用于日常的开发测试。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Minikube的安装可以参考: Minikube的Github：<a href="https://github.com/kubernetes/minikube" target="_blank" rel="external">https://github.com/kubernetes/minikube</a></p>
<p>要正常使用，还必须安装kubectl，并且放在PATH里面。kubectl是一个通过Kubernetes API和Kubernetes集群交互的命令行工具。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>可以通过minikube查看cluster运行状态,启动或者停止cluster.例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minikube start</div></pre></td></tr></table></figure>
<h3 id="ONLY-FOR-CHINESE"><a href="#ONLY-FOR-CHINESE" class="headerlink" title="ONLY FOR CHINESE"></a>ONLY FOR CHINESE</h3><p>Kubernetes在部署容器应用的时候会先拉一个pause镜像，这个是一个基础容器，主要是负责网络部分的功能的，具体这里不展开讨论。最关键的是Kubernetes里面镜像默认都是从Google的镜像仓库拉的（就跟docker默认从docker hub拉的一样），但是因为GFW的原因，中国用户是访问不了Google的镜像仓库gcr.io的（如果你可以ping通，那恭喜你）。庆幸的是这个镜像被传到了docker hub上面，虽然中国用户访问后者也非常艰难，但通过一些加速器之类的还是可以pull下来的。如果没有VPN等科学上网的工具的话，请先做如下操作：</p>
<p>See: <a href="https://github.com/kubernetes/kubernetes/issues/6888" target="_blank" rel="external">https://github.com/kubernetes/kubernetes/issues/6888</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">minikube ssh    # 登录到我们的Kubernetes VM里面去</div><div class="line">docker pull registry.hnaresearch.com/public/pause-amd64:3.0  </div><div class="line">docker tag registry.hnaresearch.com/public/pause-amd64:3.0 gcr.io/google_containers/pause-amd64:3.0</div></pre></td></tr></table></figure>
<p>这样Kubernetes VM就不会从gcr.io拉镜像了，而是会直接使用本地的镜像。</p>
<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>在Kubernetes Cluster上面部署应用，我们需要先创建一个Kubernetes Deployment。这个Deployment负责创建和更新我们的应用实例。当这个Deployment创建之后，Kubernetes master就会将这个Deployment创建出来的应用实例部署到集群内某个Node节点上。而且自应用实例创建后，Deployment controller还会持续监控应用，直到应用被删除或者部署应用的Node节点不存在。</p>
<blockquote>
<p>A Deployment is responsible for creating and updating instances of your application.</p>
</blockquote>
<p><img src="http://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg" alt=""></p>
<p>使用kubectl来创建Deployment，创建的时候需要制定容器镜像以及我们要启动的个数（replicas），当然这些信息后面可以再更新。这里我用Go写了一个简单的Webserver，返回“Hello World”，监听端口是8090.我们就来启动这个应用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl run helloworld --image=registry.hnaresearch.com/public/hello-world:v1.0 --port=8090</div></pre></td></tr></table></figure></p>
<p>执行后master寻找一个合适的node来部署我们的应用实例（我们只有一个node）。我们可以使用kubectl get deployment来查看我们创建的Deployment：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl get deployment</div></pre></td></tr></table></figure></p>
<p>默认应用部署好之后是只在Kubernetes Cluster内部可见的，有多种方法可以让我们的应用暴露到外部，这里先介绍一种简单的：我们可以通过kubectl proxy命令在我们的终端和Kubernetes Cluster直接创建一个代理。然后，打开一个新的终端，通过Pod名(Pod后面会有讲到，可以通过kubectl get pod查看Pod名字)就可以访问了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get pod</div><div class="line">NAME                             READY     STATUS             RESTARTS   AGE</div><div class="line">hello-minikube-938614450-xjl4s   0/1       ImagePullBackOff   0          15h</div><div class="line">helloworld-2790924137-bvfhn      1/1       Running            0          2m</div><div class="line"></div><div class="line">xis-macbook-pro:~ xiningwang$ curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/helloworld-2790924137-bvfhn/</div><div class="line">Hello world !</div><div class="line">hostname:helloworld-2790924137-bvfhn</div></pre></td></tr></table></figure></p>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod是Kubernetes中一个非常重要的概念，也是区别于其他编排系统的一个设计. Deployment执行时并不是直接创建了容器实例，而是先在Node上面创建了Pod，然后再在Pod里面创建容器。那Pod到底是什么？Pod是Kubernetes里面抽象出来的一个概念，它是能够被创建、调度和管理的最小单元；每个Pod都有一个独立的IP；一个Pod由若干个容器构成。一个Pod之内的容器共享Pod的所有资源，这些资源主要包括：共享存储（以Volumes的形式）、共享网络、共享端口等。Kubernetes虽然也是一个容器编排系统，但不同于其他系统，它的最小操作单元不是单个容器，而是Pod。这个特性给Kubernetes带来了很多优势，比如最显而易见的是同一个Pod内的容器可以非常方便的互相访问（通过localhost就可以访问）和共享数据。</p>
<blockquote>
<p>A Pod is a group of one or more application containers (such as Docker or rkt) and includes shared storage (volumes), IP address and information about how to run them.</p>
</blockquote>
<p><img src="http://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg" alt="pod"></p>
<blockquote>
<p>A Node is a group of one ore more pods and includes the kubelet and container engine.  </p>
<p>Containers should only be scheduled together in a single Pod if they are tightly coupled and need to share resources such as disk.</p>
</blockquote>
<p><img src="http://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg" alt="node"></p>
<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>从程序的运行形态上来区分，我们可以将Pod分为两类：长时运行服务（jboss、mysql等）和一次性任务（数据计算、测试）。Replication Controller创建的Pod都是长时运行的服务，而Job创建的Pod都是一次性任务。</p>
<p>在Job的定义中，restartPolicy（重启策略）只能是Never和OnFailure。Job可以控制一次性任务的Pod的完成次数（Job–&gt;spec–&gt;completions）和并发执行数（Job–&gt;spec–&gt;parallelism），当Pod成功执行指定次数后，即认为Job执行完毕。</p>
<h2 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h2><p>Replication Controller（RC）是Kubernetes中的另一个核心概念，应用托管在Kubernetes之后，Kubernetes需要保证应用能够持续运行，这是RC的工作内容，它会确保任何时间Kubernetes中都有指定数量的Pod在运行。在此基础上，RC还提供了一些更高级的特性，比如滚动升级、升级回滚等。</p>
<h3 id="Replica-Set"><a href="#Replica-Set" class="headerlink" title="Replica Set"></a>Replica Set</h3><p>新一代副本控制器replica set，可以被认为 是“升级版”的Replication Controller。也就是说。replica set也是用于保证与label selector匹配的pod数量维持在期望状态。区别在于，replica set引入了对基于子集的selector查询条件，而Replication Controller仅支持基于值相等的selecto条件查询。这是目前从用户角度肴，两者唯一的显著差异。 社区引入这一API的初衷是用于取代vl中的Replication Controller，也就是说．当v1版本被废弃时，Replication Controller就完成了它的历史使命，而由replica set来接管其工作。虽然replica set可以被单独使用，但是目前它多被Deployment用于进行pod的创建、更新与删除。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="id:service" target="_blank" rel="external">Service</a>是Kubernetes里面抽象出来的一层，它定义了由多个Pods组成的逻辑组（logical set），可以对组内的Pod做一些事情：</p>
<ul>
<li>对外暴露流量</li>
<li>做负载均衡（load balancing）</li>
<li>服务发现（service-discovery）</li>
</ul>
<blockquote>
<p>A Kubernetes Service is an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods.</p>
</blockquote>
<p>在Kubernetes中，在受到Replication Controller调控的时候，Pod副本是变化的，对于的虚拟IP也是变化的，比如发生迁移或者伸缩的时候。这对于Pod的访问者来说是不可接受的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略，Service同Pod的关联同样是居于Label来完成的。Service的目标是提供一种桥梁， 它会为访问者提供一个固定访问地址，用于在访问时重定向到相应的后端，这使得非 Kubernetes原生应用程序，在无须为Kubemces编写特定代码的前提下，轻松访问后端。</p>
<p>Service同RC一样，都是通过Label来关联Pod的。当你在Service的yaml文件中定义了该Service的selector中的label为app:my-web，那么这个Service会将Pod–&gt;metadata–&gt;labeks中label为app:my-web的Pod作为分发请求的后端。当Pod发生变化时（增加、减少、重建等），Service会及时更新。这样一来，Service就可以作为Pod的访问入口，起到代理服务器的作用，而对于访问者来说，通过Service进行访问，无需直接感知Pod。</p>
<p>需要注意的是，Kubernetes分配给Service的固定IP是一个虚拟IP，并不是一个真实的IP，在外部是无法寻址的。真实的系统实现上，Kubernetes是通过Kube-proxy组件来实现的虚拟IP路由及转发。所以在之前集群部署的环节上，我们在每个Node上均部署了Proxy这个组件，从而实现了Kubernetes层级的虚拟转发网络。</p>
<h3 id="Service代理服务"><a href="#Service代理服务" class="headerlink" title="Service代理服务"></a>Service代理服务</h3><p><img src="http://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg" alt="service"></p>
<p>使用kubectl get service可以查看目前已有的service，Minikube默认创建了一个kubernetes Service。我们使用expose命令再创建一个Service：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get service</div><div class="line">NAME             CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE</div><div class="line">hello-minikube   10.0.0.188   &lt;nodes&gt;       8080:32710/TCP   16h</div><div class="line">kubernetes       10.0.0.1     &lt;none&gt;        443/TCP          16h</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl expose deployment/helloworld --type=&quot;NodePort&quot; --port 8090</div><div class="line">service &quot;helloworld&quot; exposed</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get service</div><div class="line">NAME             CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE</div><div class="line">hello-minikube   10.0.0.188   &lt;nodes&gt;       8080:32710/TCP   16h</div><div class="line">helloworld       10.0.0.249   &lt;nodes&gt;       8090:31240/TCP   2m</div><div class="line">kubernetes       10.0.0.1     &lt;none&gt;        443/TCP          16h</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl delete service hello-minikube</div><div class="line">service &quot;hello-minikube&quot; deleted</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get service</div><div class="line">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE</div><div class="line">helloworld   10.0.0.249   &lt;nodes&gt;       8090:31240/TCP   2m</div><div class="line">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP          16h</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl describe service/helloworld</div><div class="line">Name:  			helloworld</div><div class="line">Namespace:     		default</div><div class="line">Labels:			run=helloworld</div><div class="line">Annotations:   		&lt;none&gt;</div><div class="line">Selector:      		run=helloworld</div><div class="line">Type:  			NodePort</div><div class="line">IP:    			10.0.0.249</div><div class="line">Port:  			&lt;unset&gt;	8090/TCP</div><div class="line">NodePort:      		&lt;unset&gt;	31240/TCP</div><div class="line">Endpoints:     		172.17.0.3:8090</div><div class="line">Session Affinity:      	None</div><div class="line">Events:			&lt;none&gt;</div><div class="line">xis-macbook-pro:~ xiningwang$ minikube docker-env</div><div class="line">export DOCKER_TLS_VERIFY=&quot;1&quot;</div><div class="line">export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;</div><div class="line">export DOCKER_CERT_PATH=&quot;/Users/xiningwang/.minikube/certs&quot;</div><div class="line">export DOCKER_API_VERSION=&quot;1.23&quot;</div><div class="line"># Run this command to configure your shell:</div><div class="line"># eval $(minikube docker-env)</div><div class="line">xis-macbook-pro:~ xiningwang$ curl http://192.168.99.100:31240</div><div class="line">Hello world !</div><div class="line">hostname:helloworld-2790924137-bvfhn</div></pre></td></tr></table></figure></p>
<h3 id="Service内部负载均衡"><a href="#Service内部负载均衡" class="headerlink" title="Service内部负载均衡"></a>Service内部负载均衡</h3><p>当Service的Endpoints包含多个IP的时候，及服务代理存在多个后端，将进行请求的负载均衡。默认的负载均衡策略是轮训或者随机（有kube-proxy的模式决定）。同时，Service上通过设置Service–&gt;spec–&gt;sessionAffinity=ClientIP，来实现基于源IP地址的会话保持。</p>
<h3 id="发布Service"><a href="#发布Service" class="headerlink" title="发布Service"></a>发布Service</h3><p>Service的虚拟IP是由Kubernetes虚拟出来的内部网络，外部是无法寻址到的。但是有些服务又需要被外部访问到，例如web前段。这时候就需要加一层网络转发，即外网到内网的转发。Kubernetes提供了NodePort、LoadBalancer、Ingress三种方式。</p>
<ul>
<li>NodePort<br>在之前的Guestbook示例中，已经延时了NodePort的用法。NodePort的原理是，Kubernetes会在每一个Node上暴露出一个端口：nodePort，外部网络可以通过（任一Node）[NodeIP]:[NodePort]访问到后端的Service。Minikube只支持这种方式。</li>
<li>LoadBalancer<br>在NodePort基础上，Kubernetes可以请求底层云平台创建一个负载均衡器，将每个Node作为后端，进行服务分发。该模式需要底层云平台（例如GCE）支持。</li>
<li>Ingress<br>是一种HTTP方式的路由转发机制，由Ingress Controller和HTTP代理服务器组合而成。Ingress Controller实时监控Kubernetes API，实时更新HTTP代理服务器的转发规则。HTTP代理服务器有GCE Load-Balancer、HaProxy、Nginx等开源方案。</li>
</ul>
<h3 id="自发性"><a href="#自发性" class="headerlink" title="自发性"></a>自发性</h3><p>Kubernetes中有一个很重要的服务自发现特性。一旦一个service被创建，该service的service IP和service port等信息都可以被注入到pod中供它们使用。Kubernetes主要支持两种service发现 机制：环境变量和DNS。</p>
<ul>
<li>环境变量方式<br>Kubernetes创建Pod时会自动添加所有可用的service环境变量到该Pod中，如有需要．这些环境变量就被注入Pod内的容器里。需要注意的是，环境变量的注入只发送在Pod创建时，且不会被自动更新。这个特点暗含了service和访问该service的Pod的创建时间的先后顺序，即任何想要访问service的pod都需要在service已经存在后创建，否则与service相关的环境变量就无法注入该Pod的容器中，这样先创建的容器就无法发现后创建的service。</li>
<li>DNS方式<br>Kubernetes集群现在支持增加一个可选的组件——DNS服务器。这个DNS服务器使用Kubernetes的watchAPI，不间断的监测新的service的创建并为每个service新建一个DNS记录。如果DNS在整个集群范围内都可用，那么所有的Pod都能够自动解析service的域名。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>多个service如何避免地址和端口冲突<br>此处设计思想是，Kubernetes通过为每个service分配一个唯一的ClusterIP，所以当使用ClusterIP：port的组合访问一个service的时候，不管port是什么，这个组合是一定不会发生重复的。另一方面，kube-proxy为每个service真正打开的是一个绝对不会重复的随机端口，用户在service描述文件中指定的访问端口会被映射到这个随机端口上。这就是为什么用户可以在创建service时随意指定访问端口。</p>
</li>
<li><p>目前存在的不足<br>Kubernetes使用iptables和kube-proxy解析service的入口地址，在中小规模的集群中运行良好，但是当service的数量超过一定规模时，仍然有一些小问题。首当其冲的便是service环境变量泛滥，以及service与使用service的pod两者创建时间先后的制约关系。目前来看，很多使用者在使用Kubernetes时往往会开发一套自己的Router组件来替代service，以便更好地掌控和定制这部分功能。</p>
</li>
</ul>
<h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>Service就是靠Label选择器（Label Selectors）来匹配组内的Pod的，而且很多命令都可以操作Label。Label是绑定在对象上（比如Pod）的键值对，主要用来把一些相关的对象组织在一起，并且对于用户来说label是有含义的，比如：</p>
<ul>
<li>Production environment (production, test, dev)</li>
<li>Application version (beta, v1.3)</li>
<li>Type of service/server (frontend, backend, database)</li>
</ul>
<blockquote>
<p>   Labels are key/value pairs that are attached to objects</p>
</blockquote>
<p><img src="http://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg" alt="Label"></p>
<h3 id="Pod创建时默认创建的Label"><a href="#Pod创建时默认创建的Label" class="headerlink" title="Pod创建时默认创建的Label"></a>Pod创建时默认创建的Label</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl describe pod helloworld-2790924137-bvfhn</div><div class="line">Name:  		helloworld-2790924137-bvfhn</div><div class="line">Namespace:     	default</div><div class="line">Node:  		minikube/192.168.99.100</div><div class="line">Start Time:    	Fri, 05 May 2017 14:03:56 +0800</div><div class="line">Labels:		pod-template-hash=2790924137</div><div class="line">       		run=helloworld</div></pre></td></tr></table></figure>
<h3 id="新增一个Label"><a href="#新增一个Label" class="headerlink" title="新增一个Label"></a>新增一个Label</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl label pod helloworld-2790924137-bvfhn app=v1</div><div class="line">pod &quot;helloworld-2790924137-bvfhn&quot; labeled</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl describe pod helloworld-2790924137-bvfhn</div><div class="line">Name:  		helloworld-2790924137-bvfhn</div><div class="line">Namespace:     	default</div><div class="line">Node:  		minikube/192.168.99.100</div><div class="line">Start Time:    	Fri, 05 May 2017 14:03:56 +0800</div><div class="line">Labels:		app=v1</div><div class="line">       		pod-template-hash=2790924137</div><div class="line">       		run=helloworld</div></pre></td></tr></table></figure>
<h3 id="使用Label的例子"><a href="#使用Label的例子" class="headerlink" title="使用Label的例子"></a>使用Label的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get service</div><div class="line">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE</div><div class="line">helloworld   10.0.0.249   &lt;nodes&gt;       8090:31240/TCP   46m</div><div class="line">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP          17h</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get service  -l run=helloworld</div><div class="line">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE</div><div class="line">helloworld   10.0.0.249   &lt;nodes&gt;       8090:31240/TCP   46m</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get pod -l app=v1</div><div class="line">NAME                          READY     STATUS    RESTARTS   AGE</div><div class="line">helloworld-2790924137-bvfhn   1/1       Running   0          1h</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get pod</div><div class="line">NAME                             READY     STATUS             RESTARTS   AGE</div><div class="line">hello-minikube-938614450-b7xwm   0/1       ImagePullBackOff   0          38m</div><div class="line">helloworld-2790924137-bvfhn      1/1       Running            0          1h</div></pre></td></tr></table></figure>
<h2 id="Pet-Sets-StatefulSet"><a href="#Pet-Sets-StatefulSet" class="headerlink" title="Pet Sets/StatefulSet"></a>Pet Sets/StatefulSet</h2><p>K8s在1.3版本里发布了Alpha版的PetSet功能。在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、宠物（pet）、有名（having name）、不可丢弃（non-disposable）。RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了、名字和启动在哪儿都不重要，重要的只是Pod总数；而PetSet是用来控制有状态服务，PetSet中的每个Pod的名字都是事先确定的，不能更改。PetSet中Pod的名字的作用，是用来关联与该Pod对应的状态。</p>
<p>对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别；对于PetSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂在上原来Pod的存储继续以它的状态提供服务。</p>
<p>适合于PetSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务。PetSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。使用PetSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，PetSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。</p>
<h2 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h2><p>在Docker的设计实现中，容器中的数据是临时的，即当容器被销毁时，其中的数据将会丢失。如果需要持久化数据，需要使用Docker数据卷挂载宿主机上的文件或者目录到容器中。在Kubernetes中，当Pod重建的时候，数据是会丢失的，Kubernetes也是通过数据卷挂载来提供Pod数据的持久化的。Kubernetes数据卷是对Docker数据卷的扩展，Kubernetes数据卷是Pod级别的，可以用来实现Pod中容器的文件共享。目前，Kubernetes支持的数据卷类型如下：</p>
<ul>
<li>本地数据卷<br>EmptyDir、HostPath这两种类型的数据卷，只能最用于本地文件系统。本地数据卷中的数据只会存在于一台机器上，所以当Pod发生迁移的时候，数据便会丢失。该类型Volume的用途是：Pod中容器间的文件共享、共享宿主机的文件系统。</li>
<li>网络数据卷<br>Kubernetes提供了很多类型的数据卷以集成第三方的存储系统，包括一些非常流行的分布式文件系统，也有在IaaS平台上提供的存储支持，这些存储系统都是分布式的，通过网络共享文件系统，因此我们称这一类数据卷为网络数据卷。<br>网络数据卷能够满足数据的持久化需求，Pod通过配置使用网络数据卷，每次Pod创建的时候都会将存储系统的远端文件目录挂载到容器中，数据卷中的数据将被水久保存，即使Pod被删除，只是除去挂载数据卷，数据卷中的数据仍然保存在存储系统中，且当新的Pod被创建的时候，仍是挂载同样的数据卷。网络数据卷包含以下几种：NFS、iSCISI、GlusterFS、RBD（Ceph Block Device）、Flocker、AWS Elastic Block Store、GCE Persistent Disk.</li>
<li>信息数据卷<br>Kubernetes中有一些数据卷，主要用来给容器传递配置信息，我们称之为信息数据卷，比如Secret（处理敏感配置信息，密码、Token等）、Downward API（通过环境变量的方式告诉容器Pod的信息）、Git Repo（将Git仓库下载到Pod中），都是将Pod的信息以文件形式保存，然后以数据卷方式挂载到容器中，容器通过读取文件获取相应的信息。</li>
</ul>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>Kubernetes提供了一种更加简单的更新RC和Pod的机制，叫做Deployment。通过在Deployment中描述你所期望的集群状态，Deployment Controller会将现在的集群状态在一个可控的速度下逐步更新成你所期望的集群状态。Deployment主要职责同样是为了保证pod的数量和健康，90%的功能与Replication Controller完全一样，可以看做新一代的Replication Controller。但是，它又具备了Replication Controller之外的新特性：</p>
<ul>
<li>Replication Controller全部功能：Deployment继承了上面描述的Replication Controller全部功能。</li>
<li>事件和状态查看：可以查看Deployment的升级详细进度和状态。</li>
<li>回滚：当升级pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。</li>
<li>版本记录: 每一次对Deployment的操作，都能保存下来，给予后续可能的回滚使用。</li>
<li>暂停和启动：对于每一次升级，都能够随时暂停和启动。</li>
<li>多种升级方案：Recreate—-删除所有已存在的pod,重新创建新的; RollingUpdate—-滚动升级，逐步替换的策略，同时滚动升级时，支持更多的附加参数，例如设置最大不可用pod数量，最小升级间隔时间等等。</li>
</ul>
<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p>随着流量的增加，我们可能需要增加我们应用的规模来满足用户的需求。Kubernetes的Scale功能就可以实现这个需求。</p>
<blockquote>
<p>   Scaling is accomplished by changing the number of replicas in a Deployment.</p>
</blockquote>
<p>扩大应用的规模时，Kubernetes将会在Nodes上面使用可用的资源来创建新的Pod，并运行新增加的应用，缩小规模时做相反的操作。Kubernetes也支持自动规模化Pod。当然我们也可以将应用的数量变为0，这样就会终止所有部署该应用的Pods。应用数量增加后，Service内的负载均衡就会变得非常有用了.</p>
<p><img src="https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg" alt="scale"></p>
<p><img src="https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg" alt="scale"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get deployment</div><div class="line">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</div><div class="line">helloworld   1         1         1            1           2h</div></pre></td></tr></table></figure>
<p>可以看到，现在我们只有一个Pod，</p>
<ul>
<li>DESIRED字段表示我们配置的replicas的个数，即实例的个数。</li>
<li>CURRENT字段表示目前处于running状态的replicas的个数。</li>
<li>UP-TO-DATE字段表示表示和预先配置的期望状态相符的replicas的个数。</li>
<li>AVAILABLE字段表示目前实际对用户可用的replicas的个数。</li>
</ul>
<p>下面我们使用kubectl scale命令将启动4个复制品，语法规则是kubectl scale deployment-type name replicas-number：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl scale deployment/helloworld --replicas=4</div><div class="line">deployment &quot;helloworld&quot; scaled</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get deployment</div><div class="line">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</div><div class="line">helloworld   4         4         4            4           2h</div><div class="line"></div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get pod -o wide</div><div class="line">NAME                          READY     STATUS    RESTARTS   AGE       IP           NODE</div><div class="line">helloworld-2790924137-2kg70   1/1       Running   0          3m        172.17.0.4   minikube</div><div class="line">helloworld-2790924137-bvfhn   1/1       Running   0          2h        172.17.0.3   minikube</div><div class="line">helloworld-2790924137-jg15m   1/1       Running   0          3m        172.17.0.5   minikube</div><div class="line">helloworld-2790924137-tgqr9   1/1       Running   0          3m        172.17.0.2   minikube</div></pre></td></tr></table></figure></p>
<p>验证一下这个Service是有负载均衡的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get deployment</div><div class="line">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</div><div class="line">helloworld   4         4         4            4           2h</div><div class="line">xis-macbook-pro:~ xiningwang$ curl 192.168.99.100:31240</div><div class="line">Hello world !</div><div class="line">hostname:helloworld-2790924137-bvfhn</div><div class="line">xis-macbook-pro:~ xiningwang$ curl 192.168.99.100:31240</div><div class="line">Hello world !</div><div class="line">hostname:helloworld-2790924137-tgqr9</div><div class="line">xis-macbook-pro:~ xiningwang$ curl 192.168.99.100:31240</div><div class="line">Hello world !</div><div class="line">hostname:helloworld-2790924137-2kg70</div><div class="line">xis-macbook-pro:~ xiningwang$ curl 192.168.99.100:31240</div><div class="line">Hello world !</div><div class="line">hostname:helloworld-2790924137-bvfhn</div><div class="line">xis-macbook-pro:~ xiningwang$ curl 192.168.99.100:31240</div><div class="line">Hello world !</div><div class="line">hostname:helloworld-2790924137-tgqr9</div></pre></td></tr></table></figure></p>
<h3 id="Rolling-Update"><a href="#Rolling-Update" class="headerlink" title="Rolling Update"></a>Rolling Update</h3><p>滚动更新（Rolling update）特性的好处就是我们不用停止服务就可以实现应用更新。默认更新的时候是一个Pod一个Pod更新的，所以整个过程服务不会中断。当然你也可以设置一次更新的Pod的百分比。而且更新过程中，Service只会将流量转发到可用的节点上面。更加重要的是，我们可以随时回退到旧版本。</p>
<blockquote>
<p>Rolling updates allow Deployments’ update to take place with zero downtime by incrementally updating Pods instances with new ones.<br>If a Deployment is exposed publicly, the Service will load-balance the traffic only to available Pods during the update.</p>
</blockquote>
<p><img src="https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg" alt="rollingupdate"><br><img src="https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg" alt="rollingupdate"><br><img src="https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg" alt="rollingupdate"><br><img src="https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg" alt="rollingupdate"></p>
<h3 id="Set-image"><a href="#Set-image" class="headerlink" title="Set image"></a>Set image</h3><p>在原来程序的基础上，多输出一个v2作为新版本，使用set image命令指定新版本镜像.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl set image deployments/helloworld helloworld=registry.hnaresearch.com/public/hello-world:v2.0</div><div class="line">deployment &quot;helloworld&quot; image updated</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get pods</div><div class="line">NAME                          READY     STATUS              RESTARTS   AGE</div><div class="line">helloworld-2790924137-2kg70   1/1       Running             0          54m</div><div class="line">helloworld-2790924137-bvfhn   1/1       Running             0          3h</div><div class="line">helloworld-2790924137-tgqr9   1/1       Running             0          54m</div><div class="line">helloworld-2889228138-65lmj   0/1       ContainerCreating   0          9m</div><div class="line">helloworld-2889228138-q68vx   0/1       ContainerCreating   0          9m</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get pods</div><div class="line">NAME                          READY     STATUS              RESTARTS   AGE</div><div class="line">helloworld-2790924137-2kg70   1/1       Terminating         0          54m</div><div class="line">helloworld-2790924137-bvfhn   1/1       Running             0          3h</div><div class="line">helloworld-2790924137-tgqr9   0/1       Terminating         0          54m</div><div class="line">helloworld-2889228138-65lmj   0/1       ContainerCreating   0          9m</div><div class="line">helloworld-2889228138-bj38m   0/1       Pending             0          9m</div><div class="line">helloworld-2889228138-dv3ch   1/1       Running             0          9m</div><div class="line">helloworld-2889228138-q68vx   1/1       Running             0          9m</div><div class="line">xis-macbook-pro:~ xiningwang$ kubectl get pods</div><div class="line">NAME                          READY     STATUS    RESTARTS   AGE</div><div class="line">helloworld-2889228138-65lmj   1/1       Running   0          10m</div><div class="line">helloworld-2889228138-bj38m   1/1       Running   0          10m</div><div class="line">helloworld-2889228138-dv3ch   1/1       Running   0          10m</div><div class="line">helloworld-2889228138-q68vx   1/1       Running   0          10m</div></pre></td></tr></table></figure></p>
<h3 id="Rollout-undo"><a href="#Rollout-undo" class="headerlink" title="Rollout undo"></a>Rollout undo</h3><p>使用kubectl rollout undo命令回滚到之前的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xis-macbook-pro:~ xiningwang$ kubectl rollout undo deployment/helloworld</div><div class="line">deployment &quot;helloworld&quot; rolled back</div></pre></td></tr></table></figure></p>
<h2 id="Autoscaling"><a href="#Autoscaling" class="headerlink" title="Autoscaling"></a>Autoscaling</h2><p>系统能够根据负载的变化对计算资源的分配进行自动的扩增或者收缩，无疑是一个非常吸引人的特征，它能够最大可能地减少费用或者其他代价（如电力损耗）。自动扩展主要分为两种，其一为水平扩展，针对于实例数目的增减；其二为垂直扩展，即单个实例可以使用的资源的增减。Horizontal Pod Autoscaler（HPA）属于前者。</p>
<p>Horizontal Pod Autoscaler的操作对象是Replication Controller、ReplicaSet或Deployment对应的Pod，根据观察到的CPU实际使用量与用户的期望值进行比对，做出是否需要增减实例数量的决策。controller目前使用heapSter来检测CPU使用量，检测周期默认是30秒。</p>
<h3 id="决策策略"><a href="#决策策略" class="headerlink" title="决策策略"></a>决策策略</h3><p>在HPA Controller检测到CPU的实际使用量之后，会求出当前的CPU使用率（实际使用量与pod 请求量的比率)。然后，HPA Controller会通过调整副本数量使得CPU使用率尽量向期望值靠近．</p>
<p>另外，考虑到自动扩展的决策可能需要一段时间才会生效，甚至在短时间内会引入一些噪声．</p>
<ul>
<li>例如当pod所需要的CPU负荷过大，从而运行一个新的pod进行分流，在创建的过程中，系统的CPU使用量可能会有一个攀升的过程。所以，在每一次作出决策后的一段时间内，将不再进行扩展决策。对于ScaleUp而言，这个时间段为3分钟，Scaledown为5分钟。</li>
<li>再者HPA Controller允许一定范围内的CPU使用量的不稳定，也就是说，只有当aVg（CurrentPodConsumption／Target低于0.9或者高于1.1时才进行实例调整，这也是出于维护系统稳定性的考虑。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/hdfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/hdfs/" itemprop="url">
                  HDFS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-09T20:46:25+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/hdfs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="hdfs/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HDFS（Hadoop Distributed File System ）Hadoop分布式文件系统。是根据google发表的论文翻版的。论文为GFS（Google File System）Google 文件系统（中文，英文）。</p>
<p>HDFS有很多特点：</p>
<ul>
<li>① 保存多个副本，且提供容错机制，副本丢失或宕机自动恢复。默认存3份。</li>
<li>② 运行在廉价的机器上。</li>
<li>③ 适合大数据的处理。多大？多小？HDFS默认会将文件分割成block，64M为1个block。然后将block按键值对存储在HDFS上，并将键值对的映射存到内存中。如果小文件太多，那内存的负担会很重。</li>
</ul>
<p><img src="/images/hdfs1.jpg" alt="hdfs1"><br>如上图所示，HDFS也是按照Master和Slave的结构。分NameNode、SecondaryNameNode、DataNode这几个角色。</p>
<ul>
<li>NameNode：是Master节点，是大领导。管理数据块映射；处理客户端的读写请求；配置副本策略；管理HDFS的名称空间；</li>
<li>SecondaryNameNode：是一个小弟，分担大哥namenode的工作量；是NameNode的冷备份；合并fsimage和fsedits然后再发给namenode。</li>
<li>DataNode：Slave节点，奴隶，干活的。负责存储client发来的数据块block；执行数据块的读写操作。</li>
<li>热备份：b是a的热备份，如果a坏掉。那么b马上运行代替a的工作。</li>
<li>冷备份：b是a的冷备份，如果a坏掉。那么b不能马上代替a工作。但是b上存储a的一些信息，减少a坏掉之后的损失。</li>
<li>fsimage:元数据镜像文件（文件系统的目录树。）</li>
<li>edits：元数据的操作日志（针对文件系统做的修改操作记录）</li>
</ul>
<p>Namenode内存中存储的是=fsimage+edits。</p>
<p>SecondaryNameNode负责定时默认1小时，从namenode上，获取fsimage和edits来进行合并，然后再发送给namenode。减少namenode的工作量。</p>
<h2 id="HDFS写操作"><a href="#HDFS写操作" class="headerlink" title="HDFS写操作"></a>HDFS写操作</h2><p>有一个文件FileA，100M大小。Client将FileA写入到HDFS上。HDFS按默认配置。HDFS分布在三个机架上Rack1，Rack2，Rack3。<br><img src="/images/hdfs-write.jpg" alt="hdfs-write"></p>
<ul>
<li>a. Client将FileA按64M分块。分成两块，block1和Block2;</li>
<li>b. Client向nameNode发送写数据请求，如图蓝色虚线①——&gt;。</li>
<li><p>c. NameNode节点，记录block信息。并返回可用的DataNode，如粉色虚线②———&gt;。</p>
<p>  Block1: host2,host1,host3</p>
<p>  Block2: host7,host8,host4</p>
<p>  原理：</p>
<pre><code>NameNode具有RackAware机架感知功能，这个可以配置。
若client为DataNode节点，那存储block时，规则为：副本1，同client的节点上；副本2，不同机架节点上；副本3，同第二个副本机架的另一个节点上；其他副本随机挑选。
若client不为DataNode节点，那存储block时，规则为：副本1，随机选择一个节点上；副本2，不同副本1，机架上；副本3，同副本2相同的另一个节点上；其他副本随机挑选。
</code></pre></li>
<li><p>d. client向DataNode发送block1；发送过程是以流式写入。</p>
<p>  流式写入过程，</p>
<pre><code>1&gt;将64M的block1按64k的package划分;

2&gt;然后将第一个package发送给host2;

3&gt;host2接收完后，将第一个package发送给host1，同时client想host2发送第二个package；

4&gt;host1接收完第一个package后，发送给host3，同时接收host2发来的第二个package。

5&gt;以此类推，如图红线实线所示，直到将block1发送完毕。

6&gt;host2,host1,host3向NameNode，host2向Client发送通知，说“消息发送完了”。如图粉红颜色实线所示。

7&gt;client收到host2发来的消息后，向namenode发送消息，说我写完了。这样就真完成了。如图黄色粗实线

8&gt;发送完block1后，再向host7，host8，host4发送block2，如图蓝色实线所示。

9&gt;发送完block2后，host7,host8,host4向NameNode，host7向Client发送通知，如图浅绿色实线所示。

10&gt;client向NameNode发送消息，说我写完了，如图黄色粗实线。。。这样就完毕了。
</code></pre></li>
</ul>
<p>分析，通过写过程，我们可以了解到：</p>
<pre><code>①写1T文件，我们需要3T的存储，3T的网络流量贷款。

②在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。

③挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。
</code></pre><h2 id="HDFS读操作"><a href="#HDFS读操作" class="headerlink" title="HDFS读操作"></a>HDFS读操作</h2><p><img src="/images/hdfs-read.jpg" alt="hdfs-read"></p>
<p>读操作就简单一些了，如图所示，client要从datanode上，读取FileA。而FileA由block1和block2组成。</p>
<p>那么，读操作流程为：</p>
<p>a. client向namenode发送读请求。</p>
<p>b. namenode查看Metadata信息，返回fileA的block的位置。</p>
<pre><code>block1:host2,host1,host3

block2:host7,host8,host4
</code></pre><p>c. block的位置是有先后顺序的，先读block1，再读block2。而且block1去host2上读取；然后block2，去host7上读取；</p>
<p>上面例子中，client位于机架外，那么如果client位于机架内某个DataNode上，例如,client是host6。那么读取的时候，遵循的规律是：</p>
<p>优选读取本机架上的数据。</p>
<h2 id="HDFS中常用到的命令"><a href="#HDFS中常用到的命令" class="headerlink" title="HDFS中常用到的命令"></a>HDFS中常用到的命令</h2><p>1、hadoop fs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">hadoop fs -ls /</div><div class="line">hadoop fs -lsr</div><div class="line">hadoop fs -mkdir /user/hadoop</div><div class="line">hadoop fs -put a.txt /user/hadoop/</div><div class="line">hadoop fs -get /user/hadoop/a.txt /</div><div class="line">hadoop fs -cp src dst</div><div class="line">hadoop fs -mv src dst</div><div class="line">hadoop fs -cat /user/hadoop/a.txt</div><div class="line">hadoop fs -rm /user/hadoop/a.txt</div><div class="line">hadoop fs -rmr /user/hadoop/a.txt</div><div class="line">hadoop fs -text /user/hadoop/a.txt</div><div class="line">hadoop fs -copyFromLocal localsrc dst 与hadoop fs -put功能类似。</div><div class="line">hadoop fs -moveFromLocal localsrc dst 将本地文件上传到hdfs，同时删除本地文件。</div></pre></td></tr></table></figure></p>
<p>2、hadoop fsadmin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hadoop dfsadmin -report</div><div class="line">hadoop dfsadmin -safemode enter | leave | get | wait</div><div class="line">hadoop dfsadmin -setBalancerBandwidth 1000</div></pre></td></tr></table></figure></p>
<p>3、hadoop fsck</p>
<p>4、start-balancer.sh</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/hbase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xi Ning Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/bio.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/hbase/" itemprop="url">
                  HBase
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-09T20:46:25+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/hbase/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="hbase/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HBase-QuickStart"><a href="#HBase-QuickStart" class="headerlink" title="HBase QuickStart"></a>HBase QuickStart</h2><p>HBase是一个开源的分布式存储系统。他可以看作是Google的Bigtable的开源实现。如同Google的Bigtable使用Google File System一样，HBase构建于和Google File System类似的Hadoop HDFS之上。</p>
<p>With the completed config, issue the command: bin/start-hbase.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-05-03 11:54:25,802 INFO  [main] http.HttpServer: Jetty bound to port 16010</div><div class="line">2017-05-03 11:54:25,802 INFO  [main] mortbay.log: jetty-6.1.26</div><div class="line">2017-05-03 11:54:25,998 INFO  [main] mortbay.log: Started SelectChannelConnector@0.0.0.0:16010</div></pre></td></tr></table></figure>
<p>Go to <a href="http://localhost:16010" target="_blank" rel="external">http://localhost:16010</a> to view the HBase Web UI.</p>
<h2 id="HBase连接池管理"><a href="#HBase连接池管理" class="headerlink" title="HBase连接池管理"></a>HBase连接池管理</h2><p>ConnectionFactory 是一个不可实例化的类，专门用于创建HBase的Connection。最简单的创建Connection实例的方式是ConnectionFactory.createConnection(config)，该方法创建了一个连接到集群的Connection实例，该实例被创建的程序管理。通过这个Connection实例，可以使用Connection.getTable()方法取得Table，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Connection connection = ConnectionFactory.createConnection(config);</div><div class="line">Table table = connection.getTable(TableName.valueOf(&quot;table1&quot;));</div><div class="line">try &#123;</div><div class="line"> // Use the table as needed, for a single operation and a single thread</div><div class="line">&#125; finally &#123;</div><div class="line"> table.close();</div><div class="line"> connection.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <em>**</em> HConnectionManager在新版本中已经不建议使用。</p>
<h2 id="HBase客户端的使用"><a href="#HBase客户端的使用" class="headerlink" title="HBase客户端的使用"></a>HBase客户端的使用</h2><p> <a href="samplecodes/hbaseclient/HBaseSample.java">客户端的使用Sample</a></p>
<h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p>Apache Cassandra是高度可扩展的，高性能的分布式NoSQL数据库。 Cassandra旨在处理许多商品服务器上的大量数据，提供高可用性而无需担心单点故障。</p>
<p>Cassandra具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，以获得高可用性，而无需担心单点故障。它在其节点之间具有对等分布式系统，数据分布在集群中的所有节点上。</p>
<ul>
<li>在Cassandra中，每个节点是独立的，同时与其他节点互连。 集群中的所有节点都扮演着相同的角色。</li>
<li>集群中的每个节点都可以接受读取和写入请求，而不管数据实际位于集群中的位置。</li>
<li>在一个节点发生故障的情况下，可以从网络中的其他节点提供读/写请求。</li>
</ul>
<h2 id="Cassandra和HBase对比"><a href="#Cassandra和HBase对比" class="headerlink" title="Cassandra和HBase对比"></a>Cassandra和HBase对比</h2><p>Cassandra可以看作是Amazon Dynamo的开源实现。和Dynamo不同之处在于，Cassandra结合了Google Bigtable的ColumnFamily的数据模型。可以简单地认为，Cassandra是一个P2P的，高可靠性并具有丰富的数据模型的分布式文件系统。</p>
<ul>
<li>Cassandra部署更简单。Cassandra只有一种角色，而HBase除了Region Server外还需要Zookeeper来同步集群状态</li>
<li>数据一致性是否可配置。Cassandra的数据一致性是可配置的，可以更改为最终一致性，而HBase是强一致性的</li>
<li>负载均衡算法不同。Cassandra通过一致性哈希来决定数据存储的位置，而HBase靠Master节点管理数据的分配，将过热的节点上的Region动态分配给负载较低的节点。因此Cassandra的平均性能会优于HBase，但是HBase有Master节点，热数据的负载更均衡。</li>
<li>单点问题。正是由于HBase存在Master节点，因此会存在单点问题。</li>
</ul>
<table><br>    <th><br>        </th><td>HBase</td><br>        <td>Cassandra</td><br>    <br>    <tr><br>        <td>语言/License/交互协议</td><br>        <td>Java/Apache/HTTP/REST (also Thrift)    </td><br>        <td>Java/Apache/Custom, binary (Thrift)</td><br>    </tr><br>    <tr><br>        <td>出发点</td><br>        <td>BigTable</td><br>        <td>BigTable and Dynamo</td><br>    </tr><br>    <tr><br>        <td>架构</td><br>        <td>master/slave    </td><br>        <td>p2p</td><br>    </tr><br>    <tr><br>        <td>高可用性</td><br>        <td>NameNode是HDFS的单点故障点    </td><br>        <td>P2P和去中心化设计，不会出现单点故障</td><br>    </tr><br>    <tr><br>        <td>伸缩性    </td><br>        <td>Region Server扩容，通过将自身发布到Master，Master均匀分布Region    </td><br>        <td>扩容需在Hash Ring上多个节点间调整数据分布</td><br>    </tr><br>    <tr><br>        <td>一致性    </td><br>        <td>强一致性    </td><br>        <td>最终一致性，Quorum NRW策略</td><br>    </tr><br>    <tr><br>        <td>存储目标/数据分布</td><br>        <td>大文件/表划分为多个region存在不同region server上    </td><br>        <td>小文件/改进的一致性哈希（虚拟节点）</td><br>    </tr><br>    <tr><br>        <td>成员通信及错误检测    </td><br>        <td>Zookeeper    </td><br>        <td>基于Gossip/P2P</td><br>    </tr><br>    <tr><br>        <td>读写性能    </td><br>        <td>数据读写定位可能要通过最多6次的网络RPC，性能较低。        </td><br>        <td>数据读写定位非常快</td><br>    </tr><br>    <tr><br>        <td>数据冲突处理    </td><br>        <td>乐观并发控制（optimistic concurrency control）        </td><br>        <td>向量时钟</td><br>    </tr><br>    <tr><br>        <td>临时故障处理    </td><br>        <td>Region Server宕机，重做HLog        </td><br>        <td>数据回传机制：某节点宕机，hash到该节点的新数据自动路由到下一节点做 hinted handoff，源节点恢复后，推送回源节点。</td><br>    </tr><br>    <tr><br>        <td>永久故障恢复        </td><br>        <td>Region Server恢复，master重新给其分配region    </td><br>        <td>Merkle 哈希树，通过Gossip协议同步Merkle Tree，维护集群节点间的数据一致性</td><br>    </tr><br>    <tr><br>        <td>CAP    </td><br>        <td>1，强一致性，0数据丢失。2，可用性低。3，扩容方便。            </td><br>        <td>1，弱一致性，数据可能丢失。2，可用性高。3，扩容方便。</td><br>    </tr><br><br></table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bio.png"
               alt="Xi Ning Wang" />
          <p class="site-author-name" itemprop="name">Xi Ning Wang</p>
           
              <p class="site-description motion-element" itemprop="description">专注于分布式高性能技术架构、IoT云平台、机器/深度学习</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xi Ning Wang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  

  

  

</body>
</html>
